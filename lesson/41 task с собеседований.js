'use strict';
//*1
// let x = 5; 
// console.log(x++);    //5  постфиксный икримент сначала возвращает значение а затем увеличивает
// console.log(x);     //6 увеличил значение 

// //*2
// let arr = [] + false - null + true;    //NaN   строка минус null == NaN
// console.log([] + false - null + true);

// console.log([] + false - null);

//*3
// let y = 1;   
// let x = y = 2; 
// console.log(x); //2  операторы  присваиваниявая являются правоассациативными

// //* 4
// console.log([ ] + 1 + 2);   //12   конкатенация пустой массив равен пустой строке

// //*5
// console.log('1'[0]);   //1   так как мы обращаемся к символу под номером [0]

// //*6
// console.log(2 && 1 && null && 0 && undefined);  // null - И останавливается на лжи и возвращает это значение

// //*7
//  let a = 5;
//  let b = 0;

//  console.log( a && b);   // вернет последнее истинное или первое ложное 
// console.log(!!(a && b)); // вариант динамической типизациивернет значение в Boolean 

// //*8 

// console.log(null || 2 && 3 || 4);  // 3  или на правде останавливается и возвращает первое true

// //*9 

// let  arr1 = [ 1, 2, 3];    // массивы хоть и идентичны но это разные хранилища информации
// let  arr2 = [ 1, 2, 3];

// console.log(arr1 == arr2);

// //*10 
// console.log(+ 'infinity');  //NaN  так как это просто строка и унарный плюс не преобразует строку к числу

// //*11 

console.log("ёжик" >  "Ёжик");   //заглавные быквы стоят выше строчных   смотри таблицу символов юникод

// //* 12 
// console.log(0 || '' || 2 || undefined || true || false);  // 2 или возвращает первое  истинное значение